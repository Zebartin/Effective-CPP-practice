# Item 9: Never call virtual functions during construction or destruction.
与Java或C#不同，在C++中，如果在基类构造或者析构过程中调用虚函数，那么在派生类构造/析构函数调用其基类构造/析构函数时，相对应的派生类虚函数并不会被调用，而只是调用了基类中的那个虚函数。

这种反直觉的机制是有它的道理的。以构造函数为例，由于基类先于派生类其他部分被初始化，在基类构造函数调用虚函数时，派生类其他部分并没有被初始化，此时如果基类构造函数中能够调用派生类对应的虚函数，由于这个虚函数可能触及到派生类特有的成员，因此可能会造成危险的后果。

更具有基础性的说法是，在派生类对基类进行初始化的过程中，对象的类型只是基类而非派生类。不只是虚函数将当前对象视为基类，其他用到运行期类型信息（runtime type information）的机制都是如此，比如`dynamic_cast`和`typeid`。这么设计的理由与上述一样。

析构的时候也是一样。在派生类调用基类的析构函数时，派生类中特有的部分被视为已经销毁，不复存在。

有时候，问题可能会隐藏在构造/析构函数中调用的某个函数中，而这个函数调用了虚函数。

如果确实有类似在构造函数中调用虚函数的需求，可以换个思路，让派生类把需要的数据传递给基类，由基类处理。

## 总结

不要在构造或析构过程中调用虚函数，因为这样的调用总是会局限在当前类而非“潜入”到派生类中。
