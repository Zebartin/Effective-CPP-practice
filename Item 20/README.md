# Item 20: Prefer pass-by-reference-to-`const` to pass-by-value.

## 按值传递存在效率问题

C++默认在函数之间按值传递，包括参数和返回值。按值传递涉及到复制构造函数，以及相应的析构函数。这会导致按值传递比较低效。按`const`引用传递在避免了复制构造函数和析构函数，提高效率的同时，也保持了按值传递不修改函数参数的特点。

## 按`const`引用传递避免了切割问题

在涉及到继承时，按值传递可能会导致切割对象（slicing）的问题，即把实参中的派生类对象切割成形参中的基类对象，进而导致多态失效。这是因为按值传递时使用了基类的复制构造函数。而按`const`引用能保留派生类对象的全部信息。

## 按`const`引用不总是最佳的

C++中引用是基于指针实现的，这意味着按引用传递相对会有更大的效率开销，所以对于内置类型来说，按值传递往往是更合适的选择。

类似的，STL中的迭代器和函数对象本来就是被设计用来按值传递的，STL实现者已经处理好上述提及的按值传递的问题。这种情况使用按值传递也更好。

## 避免按值传递

有人觉得内置类型很小，所以所有小类型都适合按值传递，哪怕是用户定义的。然而一个对象小并不意味着它的复制构造函数开销不大，比如很多STL容器，里面基本上只有一个指针，但拷贝时需要拷贝指针指向的所有内容。

哪怕是有着低开销复制构造函数的小对象，按值传递也可能会导致性能问题。这是因为有一些编译器对内置类型和自定义类型区别对待，比如一些编译器会拒绝把某个大小不大的对象放在单独一个寄存器里。

另一个避免按值传递的理由是，作为用户自定义的类型，哪怕刚开始时很小，随着项目发展可能会变大。

## 总结

- 尽量按`const`引用传递而非按值传递。通常来说前者更高效，同时能避免切割对象的问题；
- 这个规则不适用于内置类型和STL的迭代器、函数对象类型，它们使用按值传递更合适。
