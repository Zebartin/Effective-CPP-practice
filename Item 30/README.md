# Item 30: Understand the ins and outs of inlining.

## 内联可能导致代码体积膨胀

“过分热情的”内联可能会导致代码体积膨胀（code bloat），这种情况下，即使有虚拟内存，也可能导致额外的分页，使得指令缓存命中率下降，进而产生性能惩罚。

另一方面，如果内联函数的函数体非常短，则会反过来。

## 内联的两种形式

### 隐式内联

在类定义中定义（define）一个函数，比如：

```cpp
class Person
{
public:
    ...
    int age() const { return theAge; }	// implicitly inlined
    ...
private:
    int theAge;
};
```

通常这样的函数都是成员函数，不过根据[Item 46](../Item%2046)，友元函数也可能是内联函数。

### 显式内联

使用`inline`关键字。

## 关于内联的一个误解

通常来讲，模板和内联函数都定义在头文件。有些人据此会得出这样的结论：函数模板必须是内联的。这是错误的。（个人感觉不是很明白）

内联函数需要在头文件中定义的原因是，大多数系统环境（build environment）会在编译期间进行内联。为了利用内联函数的函数体进行替换，编译器需要清楚函数体是什么样子的。

模板需要在头文件中定义，同样是因为为了将模板实例化，编译器需要知道模板是怎样的。

但这两者是相互独立的。如果你觉得某个模板实例化出来的所有函数都应该是内联的，那就把这个模板声明为内联的。否则就不应该把模板声明为内联的，因为使用内联是有代价的。

## 内联是对编译器的请求而非命令

### 拒绝内联

编译器可能会拒绝内联，如果：

- 函数很复杂，比如包含有递归、循环；
- 调用虚函数（原文是all but the most trivial calls to virtual functions）：内联是编译阶段的事，而虚函数是运行时的事。

总而言之，一个内联函数是否真的内联取决于系统环境，尤其是编译器。幸运的是，大多数编译器可以在没能按预期进行内联的时候发出警告。

### 内联也可能产生函数体

哪怕编译器愿意进行内联，有时候也会为内联函数产生函数体。

比如使用函数指针指向某个内联函数，这个内联函数的函数体就会被保留下来，因为需要让函数指针有所指向。

哪怕没在使用函数指针的时候也可能会出现这种情况，因为不只是程序员在使用函数指针。有时候，在处理对象数列时，编译器会使用指向类的构造函数和析构函数的函数指针。

## 不要在构造/析构函数上使用内联

哪怕一个构造/析构函数看上去空空如也，编译器也可能会为它自动生成体量不小的代码，比如基类的构造/析构函数、异常处理等等。

## 库设计者的考虑

为库中用户可见的内联函数提供二进制更新（binary upgrades）是不可能的，如果库实现者想要修改某个内联函数的实现，所有用到这个函数的用户就必须重新编译。如果待修改的函数不是内联的，那用户只需要重新连接就可以了。

## 从程序开发的角度看

内联函数的一大问题是，大多数debugger不支持它。

因此，在程序开发过程一开始，不要内联任何东西，之后再逐步小心地进行人工优化。

不要忘了经典的八二法则：一个程序80%的执行时间会花费在只占总代码量20%的代码上。这个法则提醒我们，作为程序开发人员，我们的目标是找到这20%的代码，它们关乎着程序的整体性能。不管是内联还是什么其他手段，只有花在对的函数上才不是白费功夫。

## 总结

- 将大多数内联限制在小的、经常调用的函数上。这有利于debug和二进制更新（binary upgradability），减少潜在的代码体积膨胀，以及更有机会提高程序速度；
- 不要只是因为函数模板出现在头文件里就把它们声明为`inline`。
